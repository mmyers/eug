/*
 * ProvincePanel.java
 *
 * Created on December 20, 2007, 11:13 PM
 */

package posed;

import eug.shared.GenericList;
import eug.shared.GenericObject;
import eug.shared.ObjectVariable;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Paint;
import java.awt.Point;
import java.awt.RenderingHints;
import java.awt.geom.AffineTransform;
import java.awt.geom.Rectangle2D;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.util.logging.Level;

/**
 *
 * @author Michael Myers
 */
public class ProvincePanel extends javax.swing.JPanel {
    
    private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(ProvincePanel.class.getName());
    
    private MapPanel.ProvinceImage image;
    private BufferedImage scaledImage;
    
    private final GenericObject positionTypes; // from position_types.txt
    
    private GenericObject positionData;
    
    // the coordinates in the overall map of the upper-left corner of the image
    private double xPos;
    private double yPos;
    
    // how far it's zoomed in
    private double scale;
    
    // how much this province image is scaled to make it big enough
    // total scale = scale * ourScale
    private double ourScale;
    
    // where in the panel the image will be drawn (hopefully so that it's centered)
    //private int imageOrigin;
    
    private static final Color TEXT_DOT_COLOR = Color.BLUE;

    private static final Color[] DOT_COLORS = {
        Color.CYAN, Color.DARK_GRAY, Color.GREEN, Color.LIGHT_GRAY, Color.MAGENTA,
        Color.ORANGE, Color.PINK, Color.RED, Color.WHITE, Color.YELLOW
    };

    private int colorIdx = 0;

    private Color textColor;
    
    public ProvincePanel(GenericObject positionTypes) {
        this.positionTypes = positionTypes;
        initComponents();
        textColor = Color.BLACK;
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
    }// </editor-fold>//GEN-END:initComponents

    
    private static final RenderingHints drawingHints = new RenderingHints(null);
    static {
        drawingHints.put(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        drawingHints.put(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
        drawingHints.put(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);
        drawingHints.put(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_NORMALIZE);
        drawingHints.put(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
        drawingHints.put(RenderingHints.KEY_DITHERING, RenderingHints.VALUE_DITHER_ENABLE);
        drawingHints.put(RenderingHints.KEY_ALPHA_INTERPOLATION, RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY);
    }
    
    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);

        colorIdx = 0;
        
        if (image != null) {
            Graphics2D g2d = (Graphics2D)g;
            
            g2d.addRenderingHints(drawingHints);
            
            g2d.drawImage(scaledImage, (getWidth() - scaledImage.getWidth())/2, 0, null);
            
            Font oldFont = g2d.getFont();
            g2d.setFont(oldFont.deriveFont(Font.BOLD, (float)ourScale));
            
            Paint oldPaint = g2d.getPaint();
            g2d.setColor(textColor);
            
            // draw icons
            drawIcons(g2d, positionData, positionTypes);
            
            g2d.setPaint(oldPaint);
            g2d.setFont(oldFont);
        }
    }
    
    private void drawIcons(Graphics2D g2d, GenericObject positions, GenericObject positionTypes) {
        for (ObjectVariable var : positionTypes.values) {
            if (var.getValue().equals("xy")) {
                // Special-case text since it's always displayed
                if (var.varname.equalsIgnoreCase("text_position")) {
                    drawText(g2d);
                } else {
                    drawLocationIfPossible(var.varname, g2d, positions);
                }
            }
        }
        for (GenericObject obj : positionTypes.children) {
            drawIcons(g2d, positions.getChild(obj.name), obj);
        }
        if (positions != null && !positions.lists.isEmpty()) {
            if (positionTypes.containsList("position") && positionTypes.containsList("rotation")) {
                drawIconsFromList(g2d, positions.getList("position"), positions.getList("rotation"), positionTypes.getList("position"));
            }
        }
    }
    
    private void drawIconsFromList(Graphics2D g2d, GenericList positions, GenericList rotations, GenericList positionTypes) {
        // Lists must be in a definite order
        // If we have a list of x/y coordinates and a list of rotations, try to match them
        int i = 0;
        for (int j = 0; j < positionTypes.size(); j++) {
            String positionType = positionTypes.get(j);
            String value = positions.get(i);
            i++;
            if (i >= positions.size())
                log.log(Level.WARNING, "List did not have enough elements to match the validation: {0}", positions.getName());
            
            if (positionType.contains("/")) {
                String[] valSplit = positionType.split("/");
                String valType = valSplit[1];
                if (valType.equals("xy")) {
                    // expect two list elements for an X/Y coordinate pair
                    String val2 = positions.get(i);
                    i++;
                    
                    float x = translateX(Float.parseFloat(value));
                    float y = translateY(Float.parseFloat(val2));
                    double rotation = Double.parseDouble(rotations.get(j)); // j, not i, since i increments twice for every position type
                    drawLocation(valSplit[0], g2d, rotation, 0.0, x, y);
                }
            }
        }
    }
    
    private void drawLocationIfPossible(String name, Graphics2D g, GenericObject positions) {
        if (positions == null)
            return;
        
        GenericObject temp = positions.getChild(name);
        if (temp != null) {
            double rotation = positions.getDouble(name.split("_")[0] + "_rotation");
            double locScale = positions.getDouble(name.split("_")[0] + "_scale");

            float x = translateX(temp.getDouble("x"));
            float y = translateY(temp.getDouble("y"));
            
            drawLocation(name, g, rotation, locScale, x, y);
        }
    }
    
    private void drawLocation(String name, Graphics2D g, double rotation, double locScale, float x, float y) {

        Font oldFont = null;
        if (locScale > 0.0) {
            oldFont = g.getFont();
            float fontSize = (float) (this.scale * ourScale * locScale);
//                if (fontSize < 6.0f)
//                    fontSize = 6.0f;
//                else if (fontSize > 24.)
            g.setFont(oldFont.deriveFont(fontSize));
        } else {
            Font f = g.getFont();
            if (f.getSize() < 10) {
                oldFont = g.getFont();
                g.setFont(oldFont.deriveFont(10.0f));
            }
        }

        Rectangle2D rect = g.getFontMetrics().getStringBounds(image.getProvName(), g);

        AffineTransform at = null;
        AffineTransform oldTx = null;

        if (rotation != -1.0 && rotation != 0.0) {
//            at = AffineTransform.getTranslateInstance(x - (rect.getWidth()/2), y - (rect.getHeight()/2));
            at = AffineTransform.getTranslateInstance(x, y);
            at.rotate(-rotation);
            oldTx = g.getTransform();
            g.transform(at);
        }

        String text = (name.equalsIgnoreCase("text_position") ? image.getProvName() : name);
        if (at != null) {
            g.drawString(text, -(int) (rect.getWidth()/2), 0);
        } else {
            g.drawString(text, x - (int) (rect.getWidth()/2), y + (int) (rect.getHeight()/2));
        }

        if (oldTx != null) {
            g.setTransform(oldTx);
        }

        if (oldFont != null) {
            g.setFont(oldFont);
        }

        Paint old = g.getPaint();
        g.setColor(DOT_COLORS[(colorIdx++) % DOT_COLORS.length]);
        g.fillOval((int) x - 3, (int) y - 3, 6, 6);
        g.setPaint(old);
    }
    
    private void drawText(Graphics2D g) {
        GenericObject text = positionData != null ? positionData.getChild("text_position") : null;
        
        float x, y;
        
        if (text != null) {
            x = translateX(text.getDouble("x"));
            y = translateY(text.getDouble("y"));
        } else {
            x = (float) (image.getProvBounds().getWidth() / 2.0) * (float) ourScale;
            x += (image.getProvBounds().x - image.getImageBounds().x) * ourScale;
            x += (getWidth() - scaledImage.getWidth())/2.0;
            
            y = (float) (image.getProvBounds().getHeight() / 2.0) * (float) ourScale;
            y += (image.getProvBounds().y - image.getImageBounds().y) * ourScale;
        }

        double textScale = positionData != null ? positionData.getDouble("text_scale") : 1.0;
        double textRotation = positionData != null ? positionData.getDouble("text_rotation") : -1.0;

        Font oldFont = null;
        if (textScale > 0.0) {
            oldFont = g.getFont();
            g.setFont(oldFont.deriveFont((float) (scale * ourScale * textScale)));
        }

        Rectangle2D rect = g.getFontMetrics().getStringBounds(image.getProvName(), g);
        
        AffineTransform at = null;
        AffineTransform oldTx = null;

        if (textRotation != -1.0) {
            at = AffineTransform.getTranslateInstance(x, y);
            at.rotate(-textRotation);
            oldTx = g.getTransform();
            g.transform(at);
        }
        
        if (at != null) {
            g.drawString(image.getProvName(), -(int) (rect.getWidth()/2), 0);
        } else {
            g.drawString(image.getProvName(), x - (int) (rect.getWidth()/2), y + (int) (rect.getHeight()/2));
        }

        if (textRotation > 0.0) {
            g.setTransform(oldTx);
        }

        if (textScale > 0.0) {
            g.setFont(oldFont);
        }
        
        Paint old = g.getPaint();
        g.setColor(TEXT_DOT_COLOR);
        g.fillOval((int) x - 3, (int) y - 3, 6, 6);
        g.setPaint(old);
    }
    
    public float translateX(double coordinate) {
        // scale and add
        // x_new = (x*scale - xPos)*ourScale + imageOrigin
        coordinate *= scale;
        coordinate -= xPos;
        coordinate *= ourScale;
        
        coordinate += (getWidth() - scaledImage.getWidth())/2.0;
        return (float) coordinate;
    }
    
    public double reverseTranslateX(double coordinate) {
        coordinate -= (getWidth() - scaledImage.getWidth())/2.0;
        
        coordinate /= ourScale;
        coordinate += xPos;
        coordinate /= scale;
        
        return coordinate;
    }
    
    public float translateY(double coordinate) {
        // flip, scale, and add
        coordinate *= scale;
        coordinate += yPos;
        coordinate = image.getMapHeight() - coordinate;
        coordinate *= ourScale;
        return (float) coordinate;
    }
    
    
    public double reverseTranslateY(double coordinate) {
        coordinate /= ourScale;
        coordinate = image.getMapHeight() - coordinate;
        coordinate -= yPos;
        coordinate /= scale;
        
        return coordinate;
    }

    @Override
    public Dimension getPreferredSize() {
        if (image != null)
            return new Dimension(scaledImage.getWidth(), scaledImage.getHeight());
        return super.getPreferredSize();
    }
    
    public MapPanel.ProvinceImage getImage() {
        return image;
    }

    public void setImage(MapPanel.ProvinceImage image) {
        this.image = image;
        this.xPos = image.getImageBounds().x;
        this.yPos = image.getImageBounds().y;
        this.scale = image.getScale();
        
        this.ourScale = Math.min(20.0, 600 / image.getImageBounds().getHeight()); // try to get a height of 500
        log.log(Level.INFO, "Province image scale: {0}", ourScale);
        this.scaledImage = createScaledImage(image.getImage(), ourScale);
        
        //this.imageOrigin = (getWidth() - scaledImage.getWidth())/2;
    }
    
    private static final RenderingHints scalingHints = new RenderingHints(null);
    static {
        scalingHints.put(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);
        scalingHints.put(RenderingHints.KEY_DITHERING, RenderingHints.VALUE_DITHER_DISABLE);
        scalingHints.put(RenderingHints.KEY_COLOR_RENDERING, RenderingHints.VALUE_COLOR_RENDER_QUALITY);
    }
    
    private static BufferedImage createScaledImage(BufferedImage original, double scale) {
        final BufferedImageOp scaleOp =
                new AffineTransformOp(
                new AffineTransform(scale, 0.0, 0.0, scale, 0.0, 0.0),
                scalingHints
                );
        
        final BufferedImage ret = new BufferedImage(
                (int) Math.round(original.getWidth() * scale),
                (int) Math.round(original.getHeight() * scale),
                original.getType());
        
        Graphics2D g = ret.createGraphics();
        g.drawImage(original, scaleOp, 0, 0);
        g.dispose();
        
        return ret;
    }

    public GenericObject getPositionData() {
        return positionData;
    }

    public void setPositionData(GenericObject positionData) {
        this.positionData = positionData;
    }
    
    public int getRGB(Point point) {
        int imgOrigin = (getWidth() - scaledImage.getWidth())/2;
        if (point.x < imgOrigin ||
                point.x > imgOrigin + scaledImage.getWidth()) {
            return getBackground().getRGB();
        }
        return scaledImage.getRGB(point.x - imgOrigin, point.y);
    }

    public Color getTextColor() {
        return textColor;
    }

    public void setTextColor(Color textColor) {
        this.textColor = textColor;
    }
    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    
}
